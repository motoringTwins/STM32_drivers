/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f407xx.h"
#include "stm32f407xx_GPIO_driver.h"
#include "stm32f407xx_SPI_driver.h"
#include "string.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define CMD_LED_CRTL      0x50U
#define CMD_SENSOR_READ   0x51U
#define CMD_LED_READ      0x52U
#define CMD_PRINT         0x53U
#define CMD_ID_READ       0x54U

void delay(void)
{
	for(uint32_t i = 0; i<500000/2; i++);
}

//APi to ID read
uint8_t CmdIDReadAdruino(char* Buffer, uint32_t len)
{
	uint8_t dummy_byte = 0xff;
	uint8_t dummy_read = 0xff;
	uint8_t Cmd = CMD_ID_READ;
	uint8_t rx_buff = 0x00;

	SPI_SendData(SPI2, &Cmd, 1);
	//To clear RXNE flag
	SPI_RecieveData(SPI2, &dummy_read, 1);

	//Send dummy byte to start Receive
	SPI_SendData(SPI2, &dummy_byte, 1);
	SPI_RecieveData(SPI2, &rx_buff, 1);

	if(rx_buff == 0xF5)
	{
		uint32_t i = 0;
		for(i=0; i<len; i++)
		{
			//Send data to print
			SPI_SendData(SPI2, &dummy_byte, 1);
			SPI_RecieveData(SPI2, (uint8_t *)&Buffer[i], 1);
		}
		Buffer[i] = '\0';

		return 0xF5;
	}
	else
	{
		return 0xA5;
	}
}

//APi to Print
uint8_t CmdPrintAdruino(char* Buffer, uint32_t len)
{
	uint8_t dummy_byte = 0xff;
	uint8_t dummy_read = 0xff;
	uint8_t Cmd = CMD_PRINT;
	uint8_t rx_buff = 0x00;

	SPI_SendData(SPI2, &Cmd, 1);
	//To clear RXNE flag
	SPI_RecieveData(SPI2, &dummy_read, 1);

	//Send dummy byte to start Receive
	SPI_SendData(SPI2, &dummy_byte, 1);
	SPI_RecieveData(SPI2, &rx_buff, 1);

	if(rx_buff == 0xF5)
	{
		//Send Length Information
		SPI_SendData(SPI2, (uint8_t*)&len, 1);
		SPI_RecieveData(SPI2, &dummy_read, 1);

		for(uint32_t i = 0; i<len; i++)
		{
			//Send data to print
			SPI_SendData(SPI2, (uint8_t*)&Buffer[i], 1);
			SPI_RecieveData(SPI2, &rx_buff, 1);
		}

		return 0xF5;
	}
	else
	{
		return 0xA5;
	}
}

//APi to control LED
uint8_t CmdLedctrlAdruino(uint8_t pinNo, uint8_t OnOrOFF)
{
	uint8_t dummy_byte = 0xff;
	uint8_t dummy_read = 0xff;
	uint8_t Cmd = CMD_LED_CRTL;
	uint8_t rx_buff = 0x00;

	SPI_SendData(SPI2, &Cmd, 1);
	//To clear RXNE flag
	SPI_RecieveData(SPI2, &dummy_read, 1);

	//Send dummy byte to start Receive
	SPI_SendData(SPI2, &dummy_byte, 1);
	SPI_RecieveData(SPI2, &rx_buff, 1);

	if(rx_buff == 0xF5)
	{
		//Send pinNo and On/Off command
		SPI_SendData(SPI2, &pinNo, 1);
		//To clear RXNE flag
		SPI_RecieveData(SPI2, &dummy_read, 1);
		SPI_SendData(SPI2, &OnOrOFF, 1);
		//To clear RXNE flag
		SPI_RecieveData(SPI2, &dummy_read, 1);
		return 0xF5;
	}
	else
	{
		return 0xA5;
	}
}

//API to Read analog
uint8_t CmdReadAnalogAdruino(uint8_t pinNo, uint8_t * analog_value)
{
	uint8_t dummy_byte = 0xff;
	uint8_t dummy_read = 0xff;
	uint8_t Cmd = CMD_SENSOR_READ;
	uint8_t rx_buff = 0x00;
	SPI_SendData(SPI2, &Cmd, 1);
	SPI_RecieveData(SPI2, &dummy_read, 1);


	//Send dummy byte to start Receive
	SPI_SendData(SPI2, &dummy_byte, 1);
	SPI_RecieveData(SPI2, &rx_buff, 1);

	if(rx_buff == 0xF5)
	{
		rx_buff =0x00;
		//Send pinNo and On/Off command
		SPI_SendData(SPI2, &pinNo, 1);
		SPI_RecieveData(SPI2, &dummy_read, 1);

		//Insert delay for ADC conversion.
		delay();

		//Send dummy byte to start Receive
		SPI_SendData(SPI2, &dummy_byte, 1);
		//Recieve Analog value
		SPI_RecieveData(SPI2, &rx_buff, 1);

		*analog_value = rx_buff;
		return 0xF5;
	}
	else
	{
		return 0xA5;
	}
}

//API to Read Led
uint8_t CmdReadLedAdruino(uint8_t pinNo, uint8_t * Led_value)
{
	uint8_t dummy_byte = 0xff;
	uint8_t dummy_read = 0xff;
	uint8_t Cmd = CMD_LED_READ;
	uint8_t rx_buff = 0x00;
	SPI_SendData(SPI2, &Cmd, 1);
	SPI_RecieveData(SPI2, &dummy_read, 1);

	//Send dummy byte to start Receive
	SPI_SendData(SPI2, &dummy_byte, 1);
	SPI_RecieveData(SPI2, &rx_buff, 1);

	if(rx_buff == 0xF5)
	{
		rx_buff =0x00;
		//Send pinNo and On/Off command
		SPI_SendData(SPI2, &pinNo, 1);
		SPI_RecieveData(SPI2, &dummy_read, 1);

		//Insert delay for ADC conversion.
		delay();

		//Send dummy byte to start Receive
		SPI_SendData(SPI2, &dummy_byte, 1);
		//Recieve Analog value
		SPI_RecieveData(SPI2, &rx_buff, 1);

		*Led_value = rx_buff;
		return 0xF5;
	}
	else
	{
		return 0xA5;
	}
}

void GPIO_ButtonCfg()
{
	GPIO_handle_tst GPIO_Button;

	GPIO_Button.GPIOx_pst = GPIOA;
	GPIO_Button.GPIO_pinCfg_st.GPIO_pinNo = GPIO_PIN0;
	GPIO_Button.GPIO_pinCfg_st.GPIO_PinMode = GPIO_MODE_IN;
	GPIO_Button.GPIO_pinCfg_st.GPIO_PinOutSpeed = GPIO_OUTSPEED_HIGH;
	GPIO_Button.GPIO_pinCfg_st.GPIO_PinpupdControl = GPIO_PUPD_NONE;

	GPIO_PheripheralClockCfg(GPIO_PORTA, ENABLE);

	GPIO_init(&GPIO_Button);
}

/*SPI2 Pin Cfg
 * PB12     NSS
 * PB13     SCLK
 * PB14     MISO
 * PB15     MOSI
 */
void SPI2_PinCfg(void)
{
	GPIO_handle_tst SPI2_Pinshandle;
	memset(&SPI2_Pinshandle,0,sizeof(SPI2_Pinshandle));
	SPI2_Pinshandle.GPIOx_pst = GPIOB;

	//Enable GPIO B Peripheral
	GPIO_PheripheralClockCfg(GPIO_PORTB, ENABLE);

	//SCLK
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_pinNo = GPIO_PIN13;
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_PinMode = GPIO_MODE_ALT_FNC;
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_PinOutSpeed = GPIO_OUTSPEED_HIGH;
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_PinOutType = GPIO_OTYPE_PUSHPULL;
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_PinpupdControl = GPIO_PUPD_PU;
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_PinAltFncMode = 5;
	GPIO_init(&SPI2_Pinshandle);

	//MISO
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_pinNo = GPIO_PIN14;
	GPIO_init(&SPI2_Pinshandle);

	//MOSI
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_pinNo = GPIO_PIN15;
	GPIO_init(&SPI2_Pinshandle);

	//NSS
	SPI2_Pinshandle.GPIO_pinCfg_st.GPIO_pinNo = GPIO_PIN12;
	GPIO_init(&SPI2_Pinshandle);
}

/*
 * SPI Peripheral Initialization
 */
void SPI2_InitConfig(void)
{
	SPI_handle_tst SPI2_handle;

	SPI2_handle.SPIx_pst = SPI2;

	SPI2_handle.SPI_Config_tst.SPI_DeviceMode = SPI_DEVMODE_MASTER;
	SPI2_handle.SPI_Config_tst.SPI_CPHA = SPI_CPHA_LOW;
	SPI2_handle.SPI_Config_tst.SPI_CPOL = SPI_CPOL_LOW;
	SPI2_handle.SPI_Config_tst.SPI_BaudRate = SPI_CLKSPD_DIV8;    //2Mz SCLK
	SPI2_handle.SPI_Config_tst.SPI_BusConfig = SPI_BUSCFG_FULLDUPLEX;
	SPI2_handle.SPI_Config_tst.SPI_DFF = SPI_DFF_8BITS;
	//NSS pin to VCC for single master mode
	SPI2_handle.SPI_Config_tst.SPI_SSM = SPI_SSM_DIS;   //software Slave management disable since NSS is connected

	SPI_init(&SPI2_handle);

}

int main(void)
{
	//Configure Port A 0pin for Button
	GPIO_ButtonCfg();

	/*SPI config*/
	SPI2_PinCfg();
	SPI2_InitConfig();

	while(1)
	{
		/*
		 * LED set
		 */
		while(!GPIO_ReadInputPin(GPIOA, GPIO_PIN0));
		delay();
		/*
		 * Make SSOE to 1 since NSS pin is controlled as per SPE
		 */
		SPI_SSOEControl(SPI2, ENABLE);

		/*Enable SPI2 module*/
		SPI_PeripheralEnable(SPI2, ENABLE);

		//1. CMD_LED_CTRL <pin no(1)> <value no(1)>
		CmdLedctrlAdruino(9,1);

		/*
		 * Analog set
		 */
		while(!GPIO_ReadInputPin(GPIOA, GPIO_PIN0));
		delay();
		//Analog Pin 0
		uint8_t analog_read;
		CmdReadAnalogAdruino(0, &analog_read);

		/*
		 * Led Pin 9 read
		 */
		while(!GPIO_ReadInputPin(GPIOA, GPIO_PIN0));
		delay();
		//Led Pin 9
		uint8_t Led_read;
		CmdReadLedAdruino(0, &Led_read);

		/*
		 *Print data
		 */
		while(!GPIO_ReadInputPin(GPIOA, GPIO_PIN0));
		delay();

		char printbuffer[] = "Welcome to motoring twins channel";
		CmdPrintAdruino(printbuffer,strlen(printbuffer));

		/*
		 * CMD ID Read
		 */
		while(!GPIO_ReadInputPin(GPIOA, GPIO_PIN0));
		delay();

		char ID_Buffer[20] = {0};
		CmdIDReadAdruino(ID_Buffer,10);

		//lets confirm SPI is not busy
		while(SPI_GetBusyFlagStatus(SPI2));

		//Disable the SPI2 peripheral
		SPI_PeripheralEnable(SPI2,DISABLE);
	}

	return 0;
}

